%% ODER: format ==         = "\mathrel{==}"
%% ODER: format /=         = "\neq "
%
%
\makeatletter
\@ifundefined{lhs2tex.lhs2tex.sty.read}%
  {\@namedef{lhs2tex.lhs2tex.sty.read}{}%
   \newcommand\SkipToFmtEnd{}%
   \newcommand\EndFmtInput{}%
   \long\def\SkipToFmtEnd#1\EndFmtInput{}%
  }\SkipToFmtEnd

\newcommand\ReadOnlyOnce[1]{\@ifundefined{#1}{\@namedef{#1}{}}\SkipToFmtEnd}
\usepackage{amstext}
\usepackage{amssymb}
\usepackage{stmaryrd}
\DeclareFontFamily{OT1}{cmtex}{}
\DeclareFontShape{OT1}{cmtex}{m}{n}
  {<5><6><7><8>cmtex8
   <9>cmtex9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmtex10}{}
\DeclareFontShape{OT1}{cmtex}{m}{it}
  {<-> ssub * cmtt/m/it}{}
\newcommand{\texfamily}{\fontfamily{cmtex}\selectfont}
\DeclareFontShape{OT1}{cmtt}{bx}{n}
  {<5><6><7><8>cmtt8
   <9>cmbtt9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmbtt10}{}
\DeclareFontShape{OT1}{cmtex}{bx}{n}
  {<-> ssub * cmtt/bx/n}{}
\newcommand{\tex}[1]{\text{\texfamily#1}}	% NEU

\newcommand{\Sp}{\hskip.33334em\relax}


\newcommand{\Conid}[1]{\mathit{#1}}
\newcommand{\Varid}[1]{\mathit{#1}}
\newcommand{\anonymous}{\kern0.06em \vbox{\hrule\@width.5em}}
\newcommand{\plus}{\mathbin{+\!\!\!+}}
\newcommand{\bind}{\mathbin{>\!\!\!>\mkern-6.7mu=}}
\newcommand{\rbind}{\mathbin{=\mkern-6.7mu<\!\!\!<}}% suggested by Neil Mitchell
\newcommand{\sequ}{\mathbin{>\!\!\!>}}
\renewcommand{\leq}{\leqslant}
\renewcommand{\geq}{\geqslant}
\usepackage{polytable}

%mathindent has to be defined
\@ifundefined{mathindent}%
  {\newdimen\mathindent\mathindent\leftmargini}%
  {}%

\def\resethooks{%
  \global\let\SaveRestoreHook\empty
  \global\let\ColumnHook\empty}
\newcommand*{\savecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\savecolumns[#1]}}
\newcommand*{\restorecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\restorecolumns[#1]}}
\newcommand*{\aligncolumn}[2]%
  {\g@addto@macro\ColumnHook{\column{#1}{#2}}}

\resethooks

\newcommand{\onelinecommentchars}{\quad-{}- }
\newcommand{\commentbeginchars}{\enskip\{-}
\newcommand{\commentendchars}{-\}\enskip}

\newcommand{\visiblecomments}{%
  \let\onelinecomment=\onelinecommentchars
  \let\commentbegin=\commentbeginchars
  \let\commentend=\commentendchars}

\newcommand{\invisiblecomments}{%
  \let\onelinecomment=\empty
  \let\commentbegin=\empty
  \let\commentend=\empty}

\visiblecomments

\newlength{\blanklineskip}
\setlength{\blanklineskip}{0.66084ex}

\newcommand{\hsindent}[1]{\quad}% default is fixed indentation
\let\hspre\empty
\let\hspost\empty
\newcommand{\NB}{\textbf{NB}}
\newcommand{\Todo}[1]{$\langle$\textbf{To do:}~#1$\rangle$}

\EndFmtInput
\makeatother
%
%
%
%
%
%
% This package provides two environments suitable to take the place
% of hscode, called "plainhscode" and "arrayhscode". 
%
% The plain environment surrounds each code block by vertical space,
% and it uses \abovedisplayskip and \belowdisplayskip to get spacing
% similar to formulas. Note that if these dimensions are changed,
% the spacing around displayed math formulas changes as well.
% All code is indented using \leftskip.
%
% Changed 19.08.2004 to reflect changes in colorcode. Should work with
% CodeGroup.sty.
%
\ReadOnlyOnce{polycode.fmt}%
\makeatletter

\newcommand{\hsnewpar}[1]%
  {{\parskip=0pt\parindent=0pt\par\vskip #1\noindent}}

% can be used, for instance, to redefine the code size, by setting the
% command to \small or something alike
\newcommand{\hscodestyle}{}

% The command \sethscode can be used to switch the code formatting
% behaviour by mapping the hscode environment in the subst directive
% to a new LaTeX environment.

\newcommand{\sethscode}[1]%
  {\expandafter\let\expandafter\hscode\csname #1\endcsname
   \expandafter\let\expandafter\endhscode\csname end#1\endcsname}

% "compatibility" mode restores the non-polycode.fmt layout.

\newenvironment{compathscode}%
  {\par\noindent
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \let\hspre\(\let\hspost\)%
   \pboxed}%
  {\endpboxed\)%
   \par\noindent
   \ignorespacesafterend}

\newcommand{\compaths}{\sethscode{compathscode}}

% "plain" mode is the proposed default.
% It should now work with \centering.
% This required some changes. The old version
% is still available for reference as oldplainhscode.

\newenvironment{plainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\hspre\(\let\hspost\)%
   \pboxed}%
  {\endpboxed%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newenvironment{oldplainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

% Here, we make plainhscode the default environment.

\newcommand{\plainhs}{\sethscode{plainhscode}}
\newcommand{\oldplainhs}{\sethscode{oldplainhscode}}
\plainhs

% The arrayhscode is like plain, but makes use of polytable's
% parray environment which disallows page breaks in code blocks.

\newenvironment{arrayhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\parray}%
  {\endparray\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newcommand{\arrayhs}{\sethscode{arrayhscode}}

% The mathhscode environment also makes use of polytable's parray 
% environment. It is supposed to be used only inside math mode 
% (I used it to typeset the type rules in my thesis).

\newenvironment{mathhscode}%
  {\parray}{\endparray}

\newcommand{\mathhs}{\sethscode{mathhscode}}

% texths is similar to mathhs, but works in text mode.

\newenvironment{texthscode}%
  {\(\parray}{\endparray\)}

\newcommand{\texths}{\sethscode{texthscode}}

% The framed environment places code in a framed box.

\def\codeframewidth{\arrayrulewidth}
\RequirePackage{calc}

\newenvironment{framedhscode}%
  {\parskip=\abovedisplayskip\par\noindent
   \hscodestyle
   \arrayrulewidth=\codeframewidth
   \tabular{@{}|p{\linewidth-2\arraycolsep-2\arrayrulewidth-2pt}|@{}}%
   \hline\framedhslinecorrect\\{-1.5ex}%
   \let\endoflinesave=\\
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \framedhslinecorrect\endoflinesave{.5ex}\hline
   \endtabular
   \parskip=\belowdisplayskip\par\noindent
   \ignorespacesafterend}

\newcommand{\framedhslinecorrect}[2]%
  {#1[#2]}

\newcommand{\framedhs}{\sethscode{framedhscode}}

% The inlinehscode environment is an experimental environment
% that can be used to typeset displayed code inline.

\newenvironment{inlinehscode}%
  {\(\def\column##1##2{}%
   \let\>\undefined\let\<\undefined\let\\\undefined
   \newcommand\>[1][]{}\newcommand\<[1][]{}\newcommand\\[1][]{}%
   \def\fromto##1##2##3{##3}%
   \def\nextline{}}{\) }%

\newcommand{\inlinehs}{\sethscode{inlinehscode}}

% The joincode environment is a separate environment that
% can be used to surround and thereby connect multiple code
% blocks.

\newenvironment{joincode}%
  {\let\orighscode=\hscode
   \let\origendhscode=\endhscode
   \def\endhscode{\def\hscode{\endgroup\def\@currenvir{hscode}\\}\begingroup}
   %\let\SaveRestoreHook=\empty
   %\let\ColumnHook=\empty
   %\let\resethooks=\empty
   \orighscode\def\hscode{\endgroup\def\@currenvir{hscode}}}%
  {\origendhscode
   \global\let\hscode=\orighscode
   \global\let\endhscode=\origendhscode}%

\makeatother
\EndFmtInput
%

\ReadOnlyOnce{Formatting.fmt}%
\makeatletter

\let\Varid\mathit
\let\Conid\mathsf

\def\commentbegin{\quad\{\ }
\def\commentend{\}}

\newcommand{\ty}[1]{\Conid{#1}}
\newcommand{\con}[1]{\Conid{#1}}
\newcommand{\id}[1]{\Varid{#1}}
\newcommand{\cl}[1]{\Varid{#1}}
\newcommand{\opsym}[1]{\mathrel{#1}}

\newcommand\Keyword[1]{\textbf{\textsf{#1}}}
\newcommand\Hide{\mathbin{\downarrow}}
\newcommand\Reveal{\mathbin{\uparrow}}


%% Paper-specific keywords


\makeatother
\EndFmtInput

\section{Disscussions}
\label{sec:discussions}

% \paragraph{Syntax}
% No one could ignore the glaring shortcoming of the syntax, which occurs mainly
%  in two places: \emph{symbol singletons} and \emph{indexed monad}. We are hoping
%  that these issues could be resolved with future syntactic extensions.

\paragraph{Returning Inferable Types.} \texttt{GET} is yet another command that
is invokable only under a ``well-typed or non-existent'' precondition,
mentioned in Section~\ref{sec:disjunctive-constraints}. It fetches the value of
a key and, if the key does not exist, returns a special value \texttt{nil}. An
error is raised if the value is not a string. In \Edis{} the situation is made
slightly complex, since we parse the string to the type it was supposed to have
encoded from. The \Edis{} version of \ensuremath{\Varid{get}} could be typed:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{6}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{get}{}\<[6]%
\>[6]{}\mathbin{::}(\Conid{KnownSymbol}\;\Varid{k},\Conid{Serialize}\;\Varid{a},\Conid{StringOrNX}\;\Varid{xs}\;\Varid{k}){}\<[E]%
\\
\>[6]{}\Rightarrow \Conid{Proxy}\;\Varid{k}\to \Conid{Edis}\;\Varid{xs}\;\Varid{xs}\;(\Conid{R} \uplus \Conid{Maybe}\;\Varid{a})~~.{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
where \ensuremath{\Conid{StringOrNX}} is defined in Figure~\ref{fig:xxxOrNX}.

The problem with such typing, however, is that \ensuremath{\Varid{a}} cannot be inferred from \ensuremath{\Varid{xs}}
and \ensuremath{\Varid{k}} when \ensuremath{\Varid{k}} does not appear in \ensuremath{\Varid{xs}}. In such situations, to avoid Haskell
complaining about ambiguous type, \ensuremath{\Varid{a}} has to be specified by the caller of
\ensuremath{\Varid{get}}. The user will then be forced to spell out the complete type signature,
only to make \ensuremath{\Varid{a}} explicit.

We think it is more reasonable to enforce that, when \ensuremath{\Varid{get}} is called, the key
should exist in the data store. Thus \ensuremath{\Varid{get}} in \Redis{} has the following type:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{6}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{get}{}\<[6]%
\>[6]{}\mathbin{::}(\Conid{KnownSymbol}\;\Varid{k},\Conid{Serialize}\;\Varid{a},\Conid{Get}\;\Varid{xs}\;\Varid{k}\mathrel{\sim}\Conid{StringOf}\;\Varid{a}){}\<[E]%
\\
\>[6]{}\Rightarrow \Conid{Proxy}\;\Varid{k}\to \Conid{Edis}\;\Varid{xs}\;\Varid{xs}\;(\Conid{R} \uplus \Conid{Maybe}\;\Varid{a})~~,{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
which requires that \ensuremath{(\Varid{k},\Varid{a})} presents in \ensuremath{\Varid{xs}} and thus \ensuremath{\Varid{a}} is inferrable from
\ensuremath{\Varid{xs}} and \ensuremath{\Varid{k}}.

\paragraph{Variable Number of Input/Outputs.} Recall that, in
Section~\ref{sec:proxy-key}, the \Redis{} command \texttt{DEL} takes a variable
number of keys, while our \Edis{} counterpart takes only one. Some \Redis{}
commands take a variable number of arguments as inputs, and some returns
multiple results. Most of them are accurately implemented in \Hedis{}. For
another example of a variable-number input command, the type of \ensuremath{\Varid{sinter}} in
\Hedis{} is shown below:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{\Conid{Hedis}.sinter}\mathbin{::}[\mskip1.5mu \Conid{ByteString}\mskip1.5mu]\to \Conid{Redis}\;(\Conid{R} \uplus [\mskip1.5mu \Conid{ByteString}\mskip1.5mu])~~.{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
It takes a list of keys, values of which are all supposed to be sets, and
computes their intersection (the returned list is the intersected set).

In \Edis{}, for a function to accept a list of keys as input, we have to
specify that all the keys are in the class \ensuremath{\Conid{KnownSymbol}}. It can be done by
defining a datatype, indexed by the keys, serving as a witness that they
are all in \ensuremath{\Conid{KnownSymbol}}. We currently have not implemented such feature and
leave it as a possible future work. For now, we offer commands that take fixed
numbers of inputs. The \Edis{} version of \ensuremath{\Varid{sinter}} has type:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{12}{@{}>{\hspre}l<{\hspost}@{}}%
\column{15}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{sinter}\mathbin{::}{}\<[12]%
\>[12]{}({}\<[15]%
\>[15]{}\Conid{KnownSymbol}\;\Varid{k}_{1},\Conid{KnownSymbol}\;\Varid{k}_{2},\Conid{Serialize}\;\Varid{a},{}\<[E]%
\\
\>[15]{}\Conid{SetOf}\;\Varid{x}\mathrel{\sim}\Conid{Get}\;\Varid{xs}\;\Varid{k}_{1},\Conid{SetOf}\;\Varid{x}\mathrel{\sim}\Conid{Get}\;\Varid{xs}\;\Varid{k}_{2}){}\<[E]%
\\
\>[12]{}\Rightarrow \Conid{Proxy}\;\Varid{k}_{1}\to \Conid{Proxy}\;\Varid{k}_{2}\to \Conid{Edis}\;\Varid{xs}\;\Varid{xs}\;(\Conid{R} \uplus [\mskip1.5mu \Varid{a}\mskip1.5mu])~~.{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The function \ensuremath{\Varid{hmset}} in \Hedis{} allows one to set the values of many fields
in a hash, while \ensuremath{\Varid{hgetall}} returns all the field-value pairs of a hash. They
have the following types:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{16}{@{}>{\hspre}l<{\hspost}@{}}%
\column{33}{@{}>{\hspre}l<{\hspost}@{}}%
\column{65}{@{}>{\hspre}l<{\hspost}@{}}%
\column{98}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{\Conid{Hedis}.hmset}{}\<[16]%
\>[16]{}\mathbin{::}\Conid{ByteString}{}\<[33]%
\>[33]{}\to [\mskip1.5mu (\Conid{ByteString},\Conid{ByteString})\mskip1.5mu]{}\<[65]%
\>[65]{}\to \Conid{Redis}\;(\Conid{R} \uplus \Conid{Status}){}\<[98]%
\>[98]{}~~,{}\<[E]%
\\
\>[B]{}\Varid{\Conid{Hedis}.hgetall}{}\<[16]%
\>[16]{}\mathbin{::}\Conid{ByteString}\to \Conid{Redis}\;(\Conid{R} \uplus [\mskip1.5mu (\Conid{ByteString},\Conid{ByteString})\mskip1.5mu])~~.{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Proper implementations of them in \Edis{} should accept or return a
\emph{heterogeneous list}~\cite{hetero} --- a list whose elements can be of
different types. We also leave such functions as a future work.

\paragraph{Not All Safe Redis Programs Can Be Typechecked.}
Enforcing a typing discipline rules out some programs that are likely to be erroneous, and reduces the number of programs that are allowed. Like all type
systems, our type system takes a conservative estimation: there are bound to be
some \Redis{} programs that are not typable in our type system, but do not
actually throw a type error. We demand that elements in our lists must be
of the same type, for example, while a \Redis{} program could store in a list
different types of data, encoded as strings, and still works well.

One innate limitation is that we cannot allow dynamic generation of keys. In
\Hedis{}, the Haskell program is free to generate arbitrary sequence of keys
to be used in the data store, which is in general not possible due to the
static nature of \Edis{}.

\paragraph{Transactions.} Commands in \Redis{} can be wrapped in
\emph{transactions}. \Redis{} offers two promises regarding commands in a
transaction. Firstly, all commands in a transaction are serialized and
executed sequentially, without interruption from another client. Secondly,
either all of the commands or none are processed.

Support of transactions in \Edis{} is a future work.
We expect that there would not be too much difficulty --- in an early
experiment, we have implemented a runtime type checker specifically targeting
\Redis{} transactions, and we believe that the experience should be applicable
to static type checking as well.
