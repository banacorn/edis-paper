%% ODER: format ==         = "\mathrel{==}"
%% ODER: format /=         = "\neq "
%
%
\makeatletter
\@ifundefined{lhs2tex.lhs2tex.sty.read}%
  {\@namedef{lhs2tex.lhs2tex.sty.read}{}%
   \newcommand\SkipToFmtEnd{}%
   \newcommand\EndFmtInput{}%
   \long\def\SkipToFmtEnd#1\EndFmtInput{}%
  }\SkipToFmtEnd

\newcommand\ReadOnlyOnce[1]{\@ifundefined{#1}{\@namedef{#1}{}}\SkipToFmtEnd}
\usepackage{amstext}
\usepackage{amssymb}
\usepackage{stmaryrd}
\DeclareFontFamily{OT1}{cmtex}{}
\DeclareFontShape{OT1}{cmtex}{m}{n}
  {<5><6><7><8>cmtex8
   <9>cmtex9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmtex10}{}
\DeclareFontShape{OT1}{cmtex}{m}{it}
  {<-> ssub * cmtt/m/it}{}
\newcommand{\texfamily}{\fontfamily{cmtex}\selectfont}
\DeclareFontShape{OT1}{cmtt}{bx}{n}
  {<5><6><7><8>cmtt8
   <9>cmbtt9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmbtt10}{}
\DeclareFontShape{OT1}{cmtex}{bx}{n}
  {<-> ssub * cmtt/bx/n}{}
\newcommand{\tex}[1]{\text{\texfamily#1}}	% NEU

\newcommand{\Sp}{\hskip.33334em\relax}


\newcommand{\Conid}[1]{\mathit{#1}}
\newcommand{\Varid}[1]{\mathit{#1}}
\newcommand{\anonymous}{\kern0.06em \vbox{\hrule\@width.5em}}
\newcommand{\plus}{\mathbin{+\!\!\!+}}
\newcommand{\bind}{\mathbin{>\!\!\!>\mkern-6.7mu=}}
\newcommand{\rbind}{\mathbin{=\mkern-6.7mu<\!\!\!<}}% suggested by Neil Mitchell
\newcommand{\sequ}{\mathbin{>\!\!\!>}}
\renewcommand{\leq}{\leqslant}
\renewcommand{\geq}{\geqslant}
\usepackage{polytable}

%mathindent has to be defined
\@ifundefined{mathindent}%
  {\newdimen\mathindent\mathindent\leftmargini}%
  {}%

\def\resethooks{%
  \global\let\SaveRestoreHook\empty
  \global\let\ColumnHook\empty}
\newcommand*{\savecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\savecolumns[#1]}}
\newcommand*{\restorecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\restorecolumns[#1]}}
\newcommand*{\aligncolumn}[2]%
  {\g@addto@macro\ColumnHook{\column{#1}{#2}}}

\resethooks

\newcommand{\onelinecommentchars}{\quad-{}- }
\newcommand{\commentbeginchars}{\enskip\{-}
\newcommand{\commentendchars}{-\}\enskip}

\newcommand{\visiblecomments}{%
  \let\onelinecomment=\onelinecommentchars
  \let\commentbegin=\commentbeginchars
  \let\commentend=\commentendchars}

\newcommand{\invisiblecomments}{%
  \let\onelinecomment=\empty
  \let\commentbegin=\empty
  \let\commentend=\empty}

\visiblecomments

\newlength{\blanklineskip}
\setlength{\blanklineskip}{0.66084ex}

\newcommand{\hsindent}[1]{\quad}% default is fixed indentation
\let\hspre\empty
\let\hspost\empty
\newcommand{\NB}{\textbf{NB}}
\newcommand{\Todo}[1]{$\langle$\textbf{To do:}~#1$\rangle$}

\EndFmtInput
\makeatother
%
%
%
%
%
%
% This package provides two environments suitable to take the place
% of hscode, called "plainhscode" and "arrayhscode". 
%
% The plain environment surrounds each code block by vertical space,
% and it uses \abovedisplayskip and \belowdisplayskip to get spacing
% similar to formulas. Note that if these dimensions are changed,
% the spacing around displayed math formulas changes as well.
% All code is indented using \leftskip.
%
% Changed 19.08.2004 to reflect changes in colorcode. Should work with
% CodeGroup.sty.
%
\ReadOnlyOnce{polycode.fmt}%
\makeatletter

\newcommand{\hsnewpar}[1]%
  {{\parskip=0pt\parindent=0pt\par\vskip #1\noindent}}

% can be used, for instance, to redefine the code size, by setting the
% command to \small or something alike
\newcommand{\hscodestyle}{}

% The command \sethscode can be used to switch the code formatting
% behaviour by mapping the hscode environment in the subst directive
% to a new LaTeX environment.

\newcommand{\sethscode}[1]%
  {\expandafter\let\expandafter\hscode\csname #1\endcsname
   \expandafter\let\expandafter\endhscode\csname end#1\endcsname}

% "compatibility" mode restores the non-polycode.fmt layout.

\newenvironment{compathscode}%
  {\par\noindent
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \let\hspre\(\let\hspost\)%
   \pboxed}%
  {\endpboxed\)%
   \par\noindent
   \ignorespacesafterend}

\newcommand{\compaths}{\sethscode{compathscode}}

% "plain" mode is the proposed default.
% It should now work with \centering.
% This required some changes. The old version
% is still available for reference as oldplainhscode.

\newenvironment{plainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\hspre\(\let\hspost\)%
   \pboxed}%
  {\endpboxed%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newenvironment{oldplainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

% Here, we make plainhscode the default environment.

\newcommand{\plainhs}{\sethscode{plainhscode}}
\newcommand{\oldplainhs}{\sethscode{oldplainhscode}}
\plainhs

% The arrayhscode is like plain, but makes use of polytable's
% parray environment which disallows page breaks in code blocks.

\newenvironment{arrayhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\parray}%
  {\endparray\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newcommand{\arrayhs}{\sethscode{arrayhscode}}

% The mathhscode environment also makes use of polytable's parray 
% environment. It is supposed to be used only inside math mode 
% (I used it to typeset the type rules in my thesis).

\newenvironment{mathhscode}%
  {\parray}{\endparray}

\newcommand{\mathhs}{\sethscode{mathhscode}}

% texths is similar to mathhs, but works in text mode.

\newenvironment{texthscode}%
  {\(\parray}{\endparray\)}

\newcommand{\texths}{\sethscode{texthscode}}

% The framed environment places code in a framed box.

\def\codeframewidth{\arrayrulewidth}
\RequirePackage{calc}

\newenvironment{framedhscode}%
  {\parskip=\abovedisplayskip\par\noindent
   \hscodestyle
   \arrayrulewidth=\codeframewidth
   \tabular{@{}|p{\linewidth-2\arraycolsep-2\arrayrulewidth-2pt}|@{}}%
   \hline\framedhslinecorrect\\{-1.5ex}%
   \let\endoflinesave=\\
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \framedhslinecorrect\endoflinesave{.5ex}\hline
   \endtabular
   \parskip=\belowdisplayskip\par\noindent
   \ignorespacesafterend}

\newcommand{\framedhslinecorrect}[2]%
  {#1[#2]}

\newcommand{\framedhs}{\sethscode{framedhscode}}

% The inlinehscode environment is an experimental environment
% that can be used to typeset displayed code inline.

\newenvironment{inlinehscode}%
  {\(\def\column##1##2{}%
   \let\>\undefined\let\<\undefined\let\\\undefined
   \newcommand\>[1][]{}\newcommand\<[1][]{}\newcommand\\[1][]{}%
   \def\fromto##1##2##3{##3}%
   \def\nextline{}}{\) }%

\newcommand{\inlinehs}{\sethscode{inlinehscode}}

% The joincode environment is a separate environment that
% can be used to surround and thereby connect multiple code
% blocks.

\newenvironment{joincode}%
  {\let\orighscode=\hscode
   \let\origendhscode=\endhscode
   \def\endhscode{\def\hscode{\endgroup\def\@currenvir{hscode}\\}\begingroup}
   %\let\SaveRestoreHook=\empty
   %\let\ColumnHook=\empty
   %\let\resethooks=\empty
   \orighscode\def\hscode{\endgroup\def\@currenvir{hscode}}}%
  {\origendhscode
   \global\let\hscode=\orighscode
   \global\let\endhscode=\origendhscode}%

\makeatother
\EndFmtInput
%

\ReadOnlyOnce{Formatting.fmt}%
\makeatletter

\let\Varid\mathit
\let\Conid\mathsf

\def\commentbegin{\quad\{\ }
\def\commentend{\}}

\newcommand{\ty}[1]{\Conid{#1}}
\newcommand{\con}[1]{\Conid{#1}}
\newcommand{\id}[1]{\Varid{#1}}
\newcommand{\cl}[1]{\Varid{#1}}
\newcommand{\opsym}[1]{\mathrel{#1}}

\newcommand\Keyword[1]{\textbf{\textsf{#1}}}
\newcommand\Hide{\mathbin{\downarrow}}
\newcommand\Reveal{\mathbin{\uparrow}}


%% Paper-specific keywords


\makeatother
\EndFmtInput

\section{Introduction}
\label{sec:introduction}

\Redis{}\footnote{\url{https://redis.io}} is an open source, in-memory data
structure store that can be used as database, cache, and message broker, etc.
A \Redis{} data store can be thought of as a set of key-value pairs. The value
can be a string, a list of strings, a set of strings, or a hash table of
strings, etc. However, string is the only primitive datatype. Numbers, for
example, are serialized to strings before being saved in the data store, and
parsed back to numbers to be manipulated with. While the concept is simple,
\Redis{} is used as an essential component in a number of popular, matured services, including Twitter, GitHub, Weibo, StackOverflow, and Flickr, etc.

For an example, consider the following sequence of commands, entered through the
interactive interface of \Redis{}. The keys \texttt{some-set} and
\texttt{another-set} are both assigned a set of strings. The two calls to
command \texttt{SADD} respectively add three and two strings to the two sets,
before \texttt{SINTER} takes their intersection:
\begin{Verbatim}[xleftmargin=.4in]
redis> SADD some-set a b c
(integer) 3
redis> SADD another-set a b
(integer) 2
redis> SINTER some-set another-set
1) "a"
2) "b"
\end{Verbatim}
\noindent Notice that the keys \texttt{some-set} and \texttt{another-set}, if
not existing before the call to \texttt{SADD}, are created on site. The calls to
\texttt{SADD} return the sizes of the resulting sets.

Many third party libraries provide interfaces for general purpose programming
languages to access \Redis{} through its TCP protocol. For Haskell, the most
popular library is
\Hedis{}.\footnote{\url{https://hackage.haskell.org/package/hedis}}
A (normal) \Redis{} computation returning a value of type \ensuremath{\Varid{a}} is represented in
Haskell by \ensuremath{\Conid{Redis}\;(\Conid{Either}\;\Conid{Reply}\;\Varid{a})}, where the type \ensuremath{\Conid{Redis}} is a monad, while
\ensuremath{\Conid{Either}\;\Conid{Reply}\;\Varid{a}} indicates that the computation either returns a value of type
\ensuremath{\Varid{a}}, or fails with an error message represented by type \ensuremath{\Conid{Reply}}. The following
program implements the previous example:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{program}\mathbin{::}\Conid{Redis}\;(\Conid{Either}\;\Conid{Reply}\;[\mskip1.5mu \Conid{ByteString}\mskip1.5mu]){}\<[E]%
\\
\>[B]{}\Varid{program}\mathrel{=}\mathbf{do}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Varid{sadd}\;\text{\tt \char34 some-set\char34}\;[\mskip1.5mu \text{\tt \char34 a\char34},\text{\tt \char34 b\char34}\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Varid{sadd}\;\text{\tt \char34 another-set\char34}\;[\mskip1.5mu \text{\tt \char34 a\char34},\text{\tt \char34 b\char34},\text{\tt \char34 c\char34}\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Varid{sinter}\;[\mskip1.5mu \text{\tt \char34 some-set\char34},\text{\tt \char34 another-set\char34}\mskip1.5mu]~~.{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
The function \ensuremath{\Varid{sadd}\mathbin{::}\Conid{ByteString}\to [\mskip1.5mu \Conid{ByteString}\mskip1.5mu]\to \Conid{Redis}\;(\Conid{Either}\;\Conid{Reply}\;\Conid{Integer})} takes a key and a list of values as arguments, and returns a
\Redis{} computation yielding \ensuremath{\Conid{Integer}}. Keys and values, being nothing but
binary strings in \Redis{}, are represented using Haskell \ensuremath{\Conid{ByteString}}.

\paragraph{The Problems} Most commands work only with data of certain types. In
the following example, the key \texttt{some-string} is assigned a string
\texttt{foo} --- the command \texttt{SET} always assigns a string to a key.
The subsequent call to \texttt{SADD}, which adds a value to a set, thus raises a
runtime error.
\begin{Verbatim}[xleftmargin=.4in]
redis> SET some-string foo
OK
redis> SADD some-string bar
(error) WRONGTYPE Operation against a key holding
the wrong kind of value
\end{Verbatim}
\noindent For another source of type error, the command \texttt{INCR key}
increments the value associated with \texttt{key} by one. With strings being the
only primitive type, \Redis{} parses the stored string to an integer and, after
incrementation, stores a string back. If the string cannot be parsed as an
integer, a runtime error is raised.

The reader must have noticed the peculiar pattern of value creation and updating
in \Redis{}: the same command is used both to create a key-value pair and to
update them. Similar to \texttt{SADD}, the command \texttt{LPUSH} appends a
value (a string) to a list, or creates one if the key does not exist:
\begin{Verbatim}[xleftmargin=.4in]
redis> LPUSH some-list bar
(integer) 1
\end{Verbatim}
\noindent Another command \texttt{LLEN} returns the length of the list, and
signals an error if the key is not associated with a list:
\begin{Verbatim}[xleftmargin=.4in]
redis> LLEN some-list
(integer) 1
redis> SET some-string foo
OK
redis> LLEN some-string
(error) WRONGTYPE Operation against a key holding
the wrong kind of value
\end{Verbatim}
\noindent Curiously, however, when applied to a key not yet created, \Redis{}
designers chose to let \texttt{LLEN} return \texttt{0}:
\begin{Verbatim}[xleftmargin=.4in]
redis> LLEN nonexistent
(integer) 0
\end{Verbatim}

Being a simple wrapper on top of the TCP protocol of \Redis{}, \Hedis{}
inherits all the behaviors. Executing the following program yields the same
error, but wrapped in a Haskell constructor: \ensuremath{\Conid{Left}\;(\Conid{Error}} \texttt{"WRONGTYPE
Operation against a key holding the wrong kind of value"}\ensuremath{)}.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{program}\mathbin{::}\Conid{Redis}\;(\Conid{Either}\;\Conid{Reply}\;\Conid{Integer}){}\<[E]%
\\
\>[B]{}\Varid{program}\mathrel{=}\mathbf{do}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Varid{set}\;\text{\tt \char34 some-string\char34}\;\text{\tt \char34 foo\char34}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Varid{sadd}\;\text{\tt \char34 some-string\char34}\;[\mskip1.5mu \text{\tt \char34 a\char34}\mskip1.5mu]~~.{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Such a programming model is certainly very error-prone. Working within Haskell,
a host language with a strong typing system, one naturally wishes to build a
domain-specific embedded language (DSEL) that exploits the rich type system
of Haskell to not only ensure the absence of \Redis{} type errors, but also
provides better documentations. We wish to be sure that a program calling
\texttt{INCR}, for example, can be type checked only if we can statically
guarantee that the value to be accessed is indeed an integer. We wish to see
from the type of operators such as \texttt{LLEN} when it can be called, and
allow it to be used only in contexts that are safe. We may even want to
explicitly declare a fresh key and its type, to avoid reusing an existing key
by accident, and to prevent it from unexpectedly being used as some other type.

This paper discusses the techniques we used and the experiences we learned from
building such a language, \Edis{}. We constructed an {\em indexed monad}, on
top of the monad \ensuremath{\Conid{Redis}}, which is indexed by a dictionary that maintains the
set of currently defined keys and their types. To represent the dictionary, we
need to encode variable bindings with {\em type-level} lists and strings. And
to manipulate the dictionary, we applied various type-level programming
techniques. To summarize our contributions:
\begin{itemize}
\item We present \Edis{}, a statically typed domain-specific language embedded in Haskell and built on \Hedis{}. Serializable Haskell datatypes are
automatically converted before being written to \Redis{} data store. Available
keys and their types are kept track of in type-level dictionaries. The types of
embedded commands state clearly their preconditions and postconditions on the
available keys and types, and a program is allowed to be constructed only if
it is guaranteed not to fail with a type error.
%
\item We demonstrate the use of various type-level programming techniques,
including data kinds, singleton types and proxies, closed type families, etc.,
to define type-level lists and operations that observe and manipulate the lists.
%
\item This is (yet another) example of encoding effects and constraints of programs in types, using indexed monad~\cite{indexedmonad}, closed
type-families~\cite{tfclosed} and constraint kinds~\cite{constraintskinds}.
\end{itemize}

In Section~\ref{sec:indexed-monads} we introduce indexed monads, to reason about
pre and postconditions of stateful programs, and in Section~\ref{sec:type-level-dict} we review the basics of type-level
programming in Haskell that allows us to build type-level dictionaries to keep
track of keys and types. Embeddings of \Redis{} commands are presented in
Section~\ref{sec:embedding-commands}. In Section~\ref{sec:discussions} we
discuss various issues regarding design choices, limitations of this approach,
as well as possible future works, before we review related work in
Section~\ref{sec:conclusions}.
