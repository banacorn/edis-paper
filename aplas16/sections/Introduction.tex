%% ODER: format ==         = "\mathrel{==}"
%% ODER: format /=         = "\neq "
%
%
\makeatletter
\@ifundefined{lhs2tex.lhs2tex.sty.read}%
  {\@namedef{lhs2tex.lhs2tex.sty.read}{}%
   \newcommand\SkipToFmtEnd{}%
   \newcommand\EndFmtInput{}%
   \long\def\SkipToFmtEnd#1\EndFmtInput{}%
  }\SkipToFmtEnd

\newcommand\ReadOnlyOnce[1]{\@ifundefined{#1}{\@namedef{#1}{}}\SkipToFmtEnd}
\usepackage{amstext}
\usepackage{amssymb}
\usepackage{stmaryrd}
\DeclareFontFamily{OT1}{cmtex}{}
\DeclareFontShape{OT1}{cmtex}{m}{n}
  {<5><6><7><8>cmtex8
   <9>cmtex9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmtex10}{}
\DeclareFontShape{OT1}{cmtex}{m}{it}
  {<-> ssub * cmtt/m/it}{}
\newcommand{\texfamily}{\fontfamily{cmtex}\selectfont}
\DeclareFontShape{OT1}{cmtt}{bx}{n}
  {<5><6><7><8>cmtt8
   <9>cmbtt9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmbtt10}{}
\DeclareFontShape{OT1}{cmtex}{bx}{n}
  {<-> ssub * cmtt/bx/n}{}
\newcommand{\tex}[1]{\text{\texfamily#1}}	% NEU

\newcommand{\Sp}{\hskip.33334em\relax}


\newcommand{\Conid}[1]{\mathit{#1}}
\newcommand{\Varid}[1]{\mathit{#1}}
\newcommand{\anonymous}{\kern0.06em \vbox{\hrule\@width.5em}}
\newcommand{\plus}{\mathbin{+\!\!\!+}}
\newcommand{\bind}{\mathbin{>\!\!\!>\mkern-6.7mu=}}
\newcommand{\rbind}{\mathbin{=\mkern-6.7mu<\!\!\!<}}% suggested by Neil Mitchell
\newcommand{\sequ}{\mathbin{>\!\!\!>}}
\renewcommand{\leq}{\leqslant}
\renewcommand{\geq}{\geqslant}
\usepackage{polytable}

%mathindent has to be defined
\@ifundefined{mathindent}%
  {\newdimen\mathindent\mathindent\leftmargini}%
  {}%

\def\resethooks{%
  \global\let\SaveRestoreHook\empty
  \global\let\ColumnHook\empty}
\newcommand*{\savecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\savecolumns[#1]}}
\newcommand*{\restorecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\restorecolumns[#1]}}
\newcommand*{\aligncolumn}[2]%
  {\g@addto@macro\ColumnHook{\column{#1}{#2}}}

\resethooks

\newcommand{\onelinecommentchars}{\quad-{}- }
\newcommand{\commentbeginchars}{\enskip\{-}
\newcommand{\commentendchars}{-\}\enskip}

\newcommand{\visiblecomments}{%
  \let\onelinecomment=\onelinecommentchars
  \let\commentbegin=\commentbeginchars
  \let\commentend=\commentendchars}

\newcommand{\invisiblecomments}{%
  \let\onelinecomment=\empty
  \let\commentbegin=\empty
  \let\commentend=\empty}

\visiblecomments

\newlength{\blanklineskip}
\setlength{\blanklineskip}{0.66084ex}

\newcommand{\hsindent}[1]{\quad}% default is fixed indentation
\let\hspre\empty
\let\hspost\empty
\newcommand{\NB}{\textbf{NB}}
\newcommand{\Todo}[1]{$\langle$\textbf{To do:}~#1$\rangle$}

\EndFmtInput
\makeatother
%
%
%
%
%
%
% This package provides two environments suitable to take the place
% of hscode, called "plainhscode" and "arrayhscode". 
%
% The plain environment surrounds each code block by vertical space,
% and it uses \abovedisplayskip and \belowdisplayskip to get spacing
% similar to formulas. Note that if these dimensions are changed,
% the spacing around displayed math formulas changes as well.
% All code is indented using \leftskip.
%
% Changed 19.08.2004 to reflect changes in colorcode. Should work with
% CodeGroup.sty.
%
\ReadOnlyOnce{polycode.fmt}%
\makeatletter

\newcommand{\hsnewpar}[1]%
  {{\parskip=0pt\parindent=0pt\par\vskip #1\noindent}}

% can be used, for instance, to redefine the code size, by setting the
% command to \small or something alike
\newcommand{\hscodestyle}{}

% The command \sethscode can be used to switch the code formatting
% behaviour by mapping the hscode environment in the subst directive
% to a new LaTeX environment.

\newcommand{\sethscode}[1]%
  {\expandafter\let\expandafter\hscode\csname #1\endcsname
   \expandafter\let\expandafter\endhscode\csname end#1\endcsname}

% "compatibility" mode restores the non-polycode.fmt layout.

\newenvironment{compathscode}%
  {\par\noindent
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \let\hspre\(\let\hspost\)%
   \pboxed}%
  {\endpboxed\)%
   \par\noindent
   \ignorespacesafterend}

\newcommand{\compaths}{\sethscode{compathscode}}

% "plain" mode is the proposed default.
% It should now work with \centering.
% This required some changes. The old version
% is still available for reference as oldplainhscode.

\newenvironment{plainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\hspre\(\let\hspost\)%
   \pboxed}%
  {\endpboxed%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newenvironment{oldplainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

% Here, we make plainhscode the default environment.

\newcommand{\plainhs}{\sethscode{plainhscode}}
\newcommand{\oldplainhs}{\sethscode{oldplainhscode}}
\plainhs

% The arrayhscode is like plain, but makes use of polytable's
% parray environment which disallows page breaks in code blocks.

\newenvironment{arrayhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\parray}%
  {\endparray\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newcommand{\arrayhs}{\sethscode{arrayhscode}}

% The mathhscode environment also makes use of polytable's parray 
% environment. It is supposed to be used only inside math mode 
% (I used it to typeset the type rules in my thesis).

\newenvironment{mathhscode}%
  {\parray}{\endparray}

\newcommand{\mathhs}{\sethscode{mathhscode}}

% texths is similar to mathhs, but works in text mode.

\newenvironment{texthscode}%
  {\(\parray}{\endparray\)}

\newcommand{\texths}{\sethscode{texthscode}}

% The framed environment places code in a framed box.

\def\codeframewidth{\arrayrulewidth}
\RequirePackage{calc}

\newenvironment{framedhscode}%
  {\parskip=\abovedisplayskip\par\noindent
   \hscodestyle
   \arrayrulewidth=\codeframewidth
   \tabular{@{}|p{\linewidth-2\arraycolsep-2\arrayrulewidth-2pt}|@{}}%
   \hline\framedhslinecorrect\\{-1.5ex}%
   \let\endoflinesave=\\
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \framedhslinecorrect\endoflinesave{.5ex}\hline
   \endtabular
   \parskip=\belowdisplayskip\par\noindent
   \ignorespacesafterend}

\newcommand{\framedhslinecorrect}[2]%
  {#1[#2]}

\newcommand{\framedhs}{\sethscode{framedhscode}}

% The inlinehscode environment is an experimental environment
% that can be used to typeset displayed code inline.

\newenvironment{inlinehscode}%
  {\(\def\column##1##2{}%
   \let\>\undefined\let\<\undefined\let\\\undefined
   \newcommand\>[1][]{}\newcommand\<[1][]{}\newcommand\\[1][]{}%
   \def\fromto##1##2##3{##3}%
   \def\nextline{}}{\) }%

\newcommand{\inlinehs}{\sethscode{inlinehscode}}

% The joincode environment is a separate environment that
% can be used to surround and thereby connect multiple code
% blocks.

\newenvironment{joincode}%
  {\let\orighscode=\hscode
   \let\origendhscode=\endhscode
   \def\endhscode{\def\hscode{\endgroup\def\@currenvir{hscode}\\}\begingroup}
   %\let\SaveRestoreHook=\empty
   %\let\ColumnHook=\empty
   %\let\resethooks=\empty
   \orighscode\def\hscode{\endgroup\def\@currenvir{hscode}}}%
  {\origendhscode
   \global\let\hscode=\orighscode
   \global\let\endhscode=\origendhscode}%

\makeatother
\EndFmtInput
%

\ReadOnlyOnce{Formatting.fmt}%
\makeatletter

\let\Varid\mathit
\let\Conid\mathsf

\def\commentbegin{\quad\{\ }
\def\commentend{\}}

\newcommand{\ty}[1]{\Conid{#1}}
\newcommand{\con}[1]{\Conid{#1}}
\newcommand{\id}[1]{\Varid{#1}}
\newcommand{\cl}[1]{\Varid{#1}}
\newcommand{\opsym}[1]{\mathrel{#1}}

\newcommand\Keyword[1]{\textbf{\textsf{#1}}}
\newcommand\Hide{\mathbin{\downarrow}}
\newcommand\Reveal{\mathbin{\uparrow}}


%% Paper-specific keywords


\makeatother
\EndFmtInput

\section{Introduction}
\label{sec:introduction}

\Redis{}\footnote{\url{https://redis.io}} is an open source, in-memory data structure store, often used as database, cache and message broker. A \Redis{} datatype can be think of as a set of key-value pairs, where each value is associated with a binary-safe string key to identify and manipulate with.
\Redis{} allows values of various types, including strings, hashes, lists, and sets, etc, to be stored, and provides a collection of of atomic \emph{commands} to manipulate these values.

For an example, consider the following sequence of commands, entered through the interactive interface of \Redis{}. The keys \texttt{some-set} and \texttt{another-set}
are both associated to a set. The two call to command \texttt{SADD} respectively
adds three and two values to the two sets, before \texttt{SINTER} takes their intersection:
\begin{tabbing}\tt
~redis\char62{}~SADD~some\char45{}set~a~b~c\\
\tt ~\char40{}integer\char41{}~3\\
\tt ~redis\char62{}~SADD~another\char45{}set~a~b\\
\tt ~\char40{}integer\char41{}~2\\
\tt ~redis\char62{}~SINTER~some\char45{}set~another\char45{}set\\
\tt ~1\char41{}~\char34{}a\char34{}\\
\tt ~2\char41{}~\char34{}b\char34{}
\end{tabbing}

Note that the keys \texttt{some-set} and \texttt{another-set}, if not existing before the call to \texttt{SADD}, are created on site. The call to
\texttt{SADD} returns the size of the set after completion of the command.

Many third party libraries provide interfaces that allow general purpose programming languages to access \Redis{} through its TCP protocol.
For Haskell, the most popular library is \Hedis{}\footnote{\url{https://hackage.haskell.org/package/hedis}}.
The following program implements the previous example:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{program}\mathbin{::}\Conid{Redis}\;(\Conid{Either}\;\Conid{Reply}\;[\mskip1.5mu \Conid{ByteString}\mskip1.5mu]){}\<[E]%
\\
\>[B]{}\Varid{program}\mathrel{=}\mathbf{do}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Varid{sadd}\;\text{\tt \char34 some-set\char34}\;[\mskip1.5mu \text{\tt \char34 a\char34},\text{\tt \char34 b\char34}\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Varid{sadd}\;\text{\tt \char34 another-set\char34}\;[\mskip1.5mu \text{\tt \char34 a\char34},\text{\tt \char34 b\char34},\text{\tt \char34 c\char34}\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Varid{sinter}\;[\mskip1.5mu \text{\tt \char34 some-set\char34},\text{\tt \char34 another-set\char34}\mskip1.5mu]~~.{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
The function \ensuremath{\Varid{sadd}\mathbin{::}\Conid{ByteString}\to [\mskip1.5mu \Conid{ByteString}\mskip1.5mu]\to \Conid{Redis}\;(\Conid{Either}\;\Conid{Reply}\;\Conid{Integer})} takes a key and a list of values as arguments, and returns
an \ensuremath{\Conid{Integer}} on success, or returns a \ensuremath{\Conid{Reply}}, a low-level representation of
replies from the Redis server, in case of failures. All wrapped in the monad
\ensuremath{\Conid{Redis}}, the context of command execution.\footnotemark

Note that keys and values, being nothing but binary strings in Redis, are
represented using Haskell \ensuremath{\Conid{ByteString}}. Values of other types must be encoded
as \ensuremath{\Conid{ByteString}}s before being written to the database, and decoded after being
read back.

\footnotetext{\Hedis{} provides another kind of context, \ensuremath{\Conid{RedisTx}}, for \emph{transactions}, united with \ensuremath{\Conid{Redis}} under the class \ensuremath{\Conid{RedisCtx}}. We
demonstrate only \ensuremath{\Conid{Redis}} in this paper.}

%\paragraph{Motivation}
%All binary strings are equal, but some binary strings are more equal than others.
%While everything in \Redis{} is essentially a binary string, these strings
%are treated differently.
\Redis{} supports many different kind of data
structures, such as strings, hashes, lists, etc. While they are all encoded as
binary strings before being written to the database, most commands only works
with data of certain types. In the following example, the key
\texttt{some-string} is associated to string \texttt{foo} --- the command
\texttt{SET} always associates a key to a string. The subsequent call to \texttt{SADD}, which adds a value to a set, thus causes a runtime error.
\begin{tabbing}\tt
~redis\char62{}~SET~some\char45{}string~foo\\
\tt ~OK\\
\tt ~redis\char62{}~SADD~some\char45{}string~bar\\
\tt ~\char40{}error\char41{}~WRONGTYPE~Operation~against~a~key~holding~the~wrong\\
\tt ~kind~of~value
\end{tabbing}

%\paragraph{Example 2} Even worse, not all strings are equal!
% The call \texttt{INCR some-string} parses the string associated with key
% \texttt{some-string} to an integer, increments it by one, and store it back as
% a string. If the string can not be parse as an integer, a runtime error
% is raised.
% \begin{verbatim}
% redis> SET some-string foo
% OK
% redis> INCR some-string
% (error) ERR value is not an integer or out of range
% \end{verbatim}

Being a simple wrapper on top of the TCP protocol of \Redis{}, \Hedis{}
inherits the problem. Executing following program yields the same error
wrapped in Haskell: \ensuremath{\Conid{Left}\;(\Conid{Error}} \texttt{"WRONGTYPE Operation against a
key holding the wrong kind of value"}\ensuremath{)}.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{program}\mathbin{::}\Conid{Redis}\;(\Conid{Either}\;\Conid{Reply}\;\Conid{Integer}){}\<[E]%
\\
\>[B]{}\Varid{program}\mathrel{=}\mathbf{do}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Varid{set}\;\text{\tt \char34 some-string\char34}\;\text{\tt \char34 foo\char34}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Varid{sadd}\;\text{\tt \char34 some-string\char34}\;[\mskip1.5mu \text{\tt \char34 a\char34}\mskip1.5mu]~~.{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

% \paragraph{The Cause} Every key is associated with a value, and every value has
% its own type. But most commands in \Redis{} only work with a certain type of
%  value. When a command is used on a wrong type of key, a runtime error occurs.
%  The problems illustrated above arise from the absence of type checking, with
%  respects to \textbf{the type of a value that associates with a key}.
%  These problems could have been avoided, if we could know the type every key
%  associates with in advance, and prevent programs with invalid commands from
%  executing.
%
% \paragraph{Hedis as an embedded DSL}
% Haskell makes it easy to build and use {\em domain specific embedded languages} (DSELs), and \Hedis{} can be regarded as one of them. What makes \Hedis{} peculiar is that,
%  it has \emph{variable bindings} (between keys and values), but with very
%  little or no semantic checking, neither dynamically nor statically.
%
Such a programming model is certainly very error-prone. Working within Haskell,
a host language with a strong typing system, one naturally wishes to build a
a domain-specific embedded language (DSEL) that exploits the rich type system
of Haskell to ensure absence of \Redis{} type errors.

This paper discusses the techniques we used and experiences we learned from building such a language, nicknamed \Popcorn{}. We constructed an {\em indexed
monad}, on top of the monad \ensuremath{\Conid{Redis}}, which is indexed by a dictionary that
maintains the set of currently defined keys and their types. To represent
the dictionary, we need to encode variable binds with {\em type-level} lists
and strings. To summarize our contributions:
\begin{itemize}
\item We present \Popcorn{}, a statically typed domain-specific language embedded in Haskell and built on \Hedis{}.
% also makes Redis polymorphic by automatically converting back and forth from values of arbitrary types and boring ByteStrings.
%
\item We demonstrate how to model variable bindings of an embedded DSL using
 language extensions including type-level literals and data kinds.
%
\item We provide (yet another) an example of encoding effects and constraints of
in types, with indexed monad~\cite{indexedmonad}, closed type-families~\cite{closedtypefamilies} and constraints kinds~\cite{constraintskinds}.
\end{itemize}
\todo{Phrase this better.}
