%% ODER: format ==         = "\mathrel{==}"
%% ODER: format /=         = "\neq "
%
%
\makeatletter
\@ifundefined{lhs2tex.lhs2tex.sty.read}%
  {\@namedef{lhs2tex.lhs2tex.sty.read}{}%
   \newcommand\SkipToFmtEnd{}%
   \newcommand\EndFmtInput{}%
   \long\def\SkipToFmtEnd#1\EndFmtInput{}%
  }\SkipToFmtEnd

\newcommand\ReadOnlyOnce[1]{\@ifundefined{#1}{\@namedef{#1}{}}\SkipToFmtEnd}
\usepackage{amstext}
\usepackage{amssymb}
\usepackage{stmaryrd}
\DeclareFontFamily{OT1}{cmtex}{}
\DeclareFontShape{OT1}{cmtex}{m}{n}
  {<5><6><7><8>cmtex8
   <9>cmtex9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmtex10}{}
\DeclareFontShape{OT1}{cmtex}{m}{it}
  {<-> ssub * cmtt/m/it}{}
\newcommand{\texfamily}{\fontfamily{cmtex}\selectfont}
\DeclareFontShape{OT1}{cmtt}{bx}{n}
  {<5><6><7><8>cmtt8
   <9>cmbtt9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmbtt10}{}
\DeclareFontShape{OT1}{cmtex}{bx}{n}
  {<-> ssub * cmtt/bx/n}{}
\newcommand{\tex}[1]{\text{\texfamily#1}}	% NEU

\newcommand{\Sp}{\hskip.33334em\relax}


\newcommand{\Conid}[1]{\mathit{#1}}
\newcommand{\Varid}[1]{\mathit{#1}}
\newcommand{\anonymous}{\kern0.06em \vbox{\hrule\@width.5em}}
\newcommand{\plus}{\mathbin{+\!\!\!+}}
\newcommand{\bind}{\mathbin{>\!\!\!>\mkern-6.7mu=}}
\newcommand{\rbind}{\mathbin{=\mkern-6.7mu<\!\!\!<}}% suggested by Neil Mitchell
\newcommand{\sequ}{\mathbin{>\!\!\!>}}
\renewcommand{\leq}{\leqslant}
\renewcommand{\geq}{\geqslant}
\usepackage{polytable}

%mathindent has to be defined
\@ifundefined{mathindent}%
  {\newdimen\mathindent\mathindent\leftmargini}%
  {}%

\def\resethooks{%
  \global\let\SaveRestoreHook\empty
  \global\let\ColumnHook\empty}
\newcommand*{\savecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\savecolumns[#1]}}
\newcommand*{\restorecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\restorecolumns[#1]}}
\newcommand*{\aligncolumn}[2]%
  {\g@addto@macro\ColumnHook{\column{#1}{#2}}}

\resethooks

\newcommand{\onelinecommentchars}{\quad-{}- }
\newcommand{\commentbeginchars}{\enskip\{-}
\newcommand{\commentendchars}{-\}\enskip}

\newcommand{\visiblecomments}{%
  \let\onelinecomment=\onelinecommentchars
  \let\commentbegin=\commentbeginchars
  \let\commentend=\commentendchars}

\newcommand{\invisiblecomments}{%
  \let\onelinecomment=\empty
  \let\commentbegin=\empty
  \let\commentend=\empty}

\visiblecomments

\newlength{\blanklineskip}
\setlength{\blanklineskip}{0.66084ex}

\newcommand{\hsindent}[1]{\quad}% default is fixed indentation
\let\hspre\empty
\let\hspost\empty
\newcommand{\NB}{\textbf{NB}}
\newcommand{\Todo}[1]{$\langle$\textbf{To do:}~#1$\rangle$}

\EndFmtInput
\makeatother
%
%
%
%
%
%
% This package provides two environments suitable to take the place
% of hscode, called "plainhscode" and "arrayhscode". 
%
% The plain environment surrounds each code block by vertical space,
% and it uses \abovedisplayskip and \belowdisplayskip to get spacing
% similar to formulas. Note that if these dimensions are changed,
% the spacing around displayed math formulas changes as well.
% All code is indented using \leftskip.
%
% Changed 19.08.2004 to reflect changes in colorcode. Should work with
% CodeGroup.sty.
%
\ReadOnlyOnce{polycode.fmt}%
\makeatletter

\newcommand{\hsnewpar}[1]%
  {{\parskip=0pt\parindent=0pt\par\vskip #1\noindent}}

% can be used, for instance, to redefine the code size, by setting the
% command to \small or something alike
\newcommand{\hscodestyle}{}

% The command \sethscode can be used to switch the code formatting
% behaviour by mapping the hscode environment in the subst directive
% to a new LaTeX environment.

\newcommand{\sethscode}[1]%
  {\expandafter\let\expandafter\hscode\csname #1\endcsname
   \expandafter\let\expandafter\endhscode\csname end#1\endcsname}

% "compatibility" mode restores the non-polycode.fmt layout.

\newenvironment{compathscode}%
  {\par\noindent
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \let\hspre\(\let\hspost\)%
   \pboxed}%
  {\endpboxed\)%
   \par\noindent
   \ignorespacesafterend}

\newcommand{\compaths}{\sethscode{compathscode}}

% "plain" mode is the proposed default.
% It should now work with \centering.
% This required some changes. The old version
% is still available for reference as oldplainhscode.

\newenvironment{plainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\hspre\(\let\hspost\)%
   \pboxed}%
  {\endpboxed%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newenvironment{oldplainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

% Here, we make plainhscode the default environment.

\newcommand{\plainhs}{\sethscode{plainhscode}}
\newcommand{\oldplainhs}{\sethscode{oldplainhscode}}
\plainhs

% The arrayhscode is like plain, but makes use of polytable's
% parray environment which disallows page breaks in code blocks.

\newenvironment{arrayhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\parray}%
  {\endparray\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newcommand{\arrayhs}{\sethscode{arrayhscode}}

% The mathhscode environment also makes use of polytable's parray 
% environment. It is supposed to be used only inside math mode 
% (I used it to typeset the type rules in my thesis).

\newenvironment{mathhscode}%
  {\parray}{\endparray}

\newcommand{\mathhs}{\sethscode{mathhscode}}

% texths is similar to mathhs, but works in text mode.

\newenvironment{texthscode}%
  {\(\parray}{\endparray\)}

\newcommand{\texths}{\sethscode{texthscode}}

% The framed environment places code in a framed box.

\def\codeframewidth{\arrayrulewidth}
\RequirePackage{calc}

\newenvironment{framedhscode}%
  {\parskip=\abovedisplayskip\par\noindent
   \hscodestyle
   \arrayrulewidth=\codeframewidth
   \tabular{@{}|p{\linewidth-2\arraycolsep-2\arrayrulewidth-2pt}|@{}}%
   \hline\framedhslinecorrect\\{-1.5ex}%
   \let\endoflinesave=\\
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \framedhslinecorrect\endoflinesave{.5ex}\hline
   \endtabular
   \parskip=\belowdisplayskip\par\noindent
   \ignorespacesafterend}

\newcommand{\framedhslinecorrect}[2]%
  {#1[#2]}

\newcommand{\framedhs}{\sethscode{framedhscode}}

% The inlinehscode environment is an experimental environment
% that can be used to typeset displayed code inline.

\newenvironment{inlinehscode}%
  {\(\def\column##1##2{}%
   \let\>\undefined\let\<\undefined\let\\\undefined
   \newcommand\>[1][]{}\newcommand\<[1][]{}\newcommand\\[1][]{}%
   \def\fromto##1##2##3{##3}%
   \def\nextline{}}{\) }%

\newcommand{\inlinehs}{\sethscode{inlinehscode}}

% The joincode environment is a separate environment that
% can be used to surround and thereby connect multiple code
% blocks.

\newenvironment{joincode}%
  {\let\orighscode=\hscode
   \let\origendhscode=\endhscode
   \def\endhscode{\def\hscode{\endgroup\def\@currenvir{hscode}\\}\begingroup}
   %\let\SaveRestoreHook=\empty
   %\let\ColumnHook=\empty
   %\let\resethooks=\empty
   \orighscode\def\hscode{\endgroup\def\@currenvir{hscode}}}%
  {\origendhscode
   \global\let\hscode=\orighscode
   \global\let\endhscode=\origendhscode}%

\makeatother
\EndFmtInput
%

\ReadOnlyOnce{Formatting.fmt}%
\makeatletter

\let\Varid\mathit
\let\Conid\mathsf

\def\commentbegin{\quad\{\ }
\def\commentend{\}}

\newcommand{\ty}[1]{\Conid{#1}}
\newcommand{\con}[1]{\Conid{#1}}
\newcommand{\id}[1]{\Varid{#1}}
\newcommand{\cl}[1]{\Varid{#1}}
\newcommand{\opsym}[1]{\mathrel{#1}}

\newcommand\Keyword[1]{\textbf{\textsf{#1}}}
\newcommand\Hide{\mathbin{\downarrow}}
\newcommand\Reveal{\mathbin{\uparrow}}


%% Paper-specific keywords


\makeatother
\EndFmtInput

\section{Embedding \Hedis{} Commands}
\label{sec:embedding-commands}

Having the indexed monads and type-level dictionaries, in this section we
present our embedding of \Hedis{} commands into \Edis{}, while introducing
necessary concepts when they are used.

\subsection{Proxies and Singleton Types}

The \Hedis{} function \ensuremath{\Varid{del}\mathbin{::}[\mskip1.5mu \Conid{ByteString}\mskip1.5mu]\to \Conid{Either}\;\Conid{Reply}\;\Conid{Integer}} takes a list
of keys (encoded to \ensuremath{\Conid{ByteString}}) and removes the entries having those keys in
the database. For simplicity, we consider creating a \Edis{} counterpart
that takes only one key. A first attempt may lead to something like the
following:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{del}\mathbin{::}\Conid{String}\to \Conid{Edis}\;\Varid{xs}\;(\Conid{Del}\;\Varid{xs}~\mathbin{?})\;(\Conid{Either}\;\Conid{Reply}\;\Conid{Integer}){}\<[E]%
\\
\>[B]{}\Varid{del}\;\Varid{key}\mathrel{=}\Conid{Edis}\mathbin{\$}\Varid{\Conid{Hedis}.del}\;[\mskip1.5mu \Varid{encode}\;\Varid{key}\mskip1.5mu]~~,{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
where the function \ensuremath{\Varid{encode}} converts \ensuremath{\Conid{String}} to \ensuremath{\Conid{ByteString}}. At term-level,
our \ensuremath{\Varid{del}} merely calls \ensuremath{\Varid{\Conid{Hedis}.del}}. At
type-level, if the status of the database before \ensuremath{\Varid{del}} is called is specified
by the dictionary \ensuremath{\Varid{xs}}, the status afterwards should be specified by
\ensuremath{\Conid{Del}\;\Varid{xs}~\mathbin{?}}. The question, however, is what to fill in place of the
question mark. It cannot be \ensuremath{\Conid{Del}\;\Varid{xs}\;\Varid{key}}, since \ensuremath{\Varid{key}} is a runtime value and
not a type. How do we smuggle a runtime value to type-level?

In a language with phase distinction like Haskell, it is certainly impossible
to pass the value of \ensuremath{\Varid{key}} to the type checker if it truly is a runtime value,
for example, a string read from the user. If the value of \ensuremath{\Varid{key}} can be
determined statically, however, {\em singleton types} can be used to represent a
type as a value, thus build a connection between the two realms.

A singleton type is a type that has only one term. When the term is built, it
carries a type that can be inspected by the type checker. The term can be think
of as a representative of its type at the realm of runtime values. For our
purpose, we will use the following type \ensuremath{\Conid{Proxy}}:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{data}\;\Conid{Proxy}\;\Varid{t}\mathrel{=}\Conid{Proxy}~~.{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
For every type \ensuremath{\Varid{t}}, \ensuremath{\Conid{Proxy}\;\Varid{t}} is a type that has only one term: \ensuremath{\Conid{Proxy}}.%
\footnote{While giving the same name to both the type and the term can be very
confusing, it is unfortunately a common practice in the Haskell community.}
To call \ensuremath{\Varid{del}}, instead of passing a key as a \ensuremath{\Conid{String}}, we give it a proxy with
a specified type:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{del}\;(\Conid{Proxy}\mathbin{::}\Conid{Proxy}\;\text{\tt \char34 A\char34})~~,{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
where \ensuremath{\text{\tt \char34 A\char34}} is not a value, but a string lifted to a type (of kind \ensuremath{\Conid{Symbol}}).
Now that the type checker has access to the key, the type of \ensuremath{\Varid{del}} could be
something alone the line of \ensuremath{\Varid{del}\mathbin{::}\Conid{Proxy}\;\Varid{s}\to \Conid{Edis}\;\Varid{xs}\;(\Conid{Del}\;\Varid{xs}\;\Varid{s})\mathbin{...}}.

The next problem is that, \ensuremath{\Varid{del}}, at term level, gets only a value constructor
\ensuremath{\Conid{Proxy}} without further information, while it needs to pass a \ensuremath{\Conid{ByteString}} key
to \ensuremath{\Varid{\Conid{Hedis}.del}}. Every concrete string literal lifted to a type, for example
\ensuremath{\text{\tt \char34 A\char34}}, belongs to a type class \ensuremath{\Conid{KnownSymbol}}. For all type \ensuremath{\Varid{n}} in \ensuremath{\Conid{KnownSymbol}},
the function \ensuremath{\Varid{symbolVal}}:\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{symbolVal}\mathbin{::}\Conid{KnownSymbol}\;\Varid{n}\Rightarrow \Varid{proxy}\;\Varid{n}\to \Conid{String}~~,{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
retrieves the string associated with a type-level literal that is known at
compile time. In summary, \ensuremath{\Varid{del}} can be implemented as:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{6}{@{}>{\hspre}l<{\hspost}@{}}%
\column{45}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{del}{}\<[6]%
\>[6]{}\mathbin{::}\Conid{KnownSymbol}\;\Varid{s}{}\<[E]%
\\
\>[6]{}\Rightarrow \Conid{Proxy}\;\Varid{s}\to \Conid{Edis}\;\Varid{xs}\;(\Conid{Del}\;\Varid{xs}\;\Varid{s})\;(\Conid{Either}\;\Conid{Reply}\;\Conid{Integer}){}\<[E]%
\\
\>[B]{}\Varid{del}\;\Varid{key}\mathrel{=}\Conid{Edis}\;(\Varid{\Conid{Hedis}.del}\;[\mskip1.5mu \Varid{encodeKey}\;\Varid{key}\mskip1.5mu]){}\<[45]%
\>[45]{}~~,{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
where \ensuremath{\Varid{encodeKey}\mathrel{=}\Varid{encode}\mathbin{\cdot}\Varid{symbolVal}}.

A final note: the function \ensuremath{\Varid{encode}}, from the Haskell library {\sc cereal},
helps to convert certain datatype that are {\em serializable} into \ensuremath{\Conid{ByteString}}.
The function and its dual \ensuremath{\Varid{decode}} will be use more later.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{encode}{}\<[9]%
\>[9]{}\mathbin{::}\Conid{Serialize}\;\Varid{a}\Rightarrow \Varid{a}\to \Conid{ByteString}~~,{}\<[E]%
\\
\>[B]{}\Varid{decode}{}\<[9]%
\>[9]{}\mathbin{::}\Conid{Serialize}\;\Varid{a}\Rightarrow \Conid{ByteString}\to \Conid{Either}\;\Conid{String}\;\Varid{a}~~.{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\subsection{Storing Primitive Datatypes Other Than Strings}
\label{sec:polymorphic-redis}

As mentioned before, while \Redis{} provide a number of container types
including lists, sets, and hash, etc., the primitive type is string.
\Hedis{} programmers manually convert other types of data to strings before
saving them into the data store. In \Edis{}, we wish to save some of the
effort for the programmers, as well as keeping a careful record of the intended
types of the strings in the data store.

To keep track of intended types of strings in the data store, we define the
following types (that have no terms):
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{data}\;\Conid{StringOf}\;\Varid{x}~~,{}\<[E]%
\\
\>[B]{}\mathbf{data}\;\Conid{ListOf}\;\Varid{x}~~,{}\<[E]%
\\
\>[B]{}\mathbf{data}\;\Conid{SetOf}\;\Varid{x}~~...{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
If an key is associated with, for example, \ensuremath{\Conid{StringOf}\;\Conid{Int}} in
our dictionary, we mean that its associated value in the data store was
serialized from an \ensuremath{\Conid{Int}} and should be used as an \ensuremath{\Conid{Int}}. Types
\ensuremath{\Conid{ListOf}\;\Varid{x}} and \ensuremath{\Conid{SetOf}\;\Varid{x}}, respectively, denotes that the value is a list
or a set of the given type.

While the \ensuremath{\Varid{set}} command in \Hedis{} always writes a string to the data store,
the corresponding \ensuremath{\Varid{set}} in \Redis{} applies to any serializable type (those
in the class \ensuremath{\Conid{Serialize}}), and performs the encoding for the user:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{6}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{set}{}\<[6]%
\>[6]{}\mathbin{::}(\Conid{KnownSymbol}\;\Varid{s},\Conid{Serialize}\;\Varid{x}){}\<[E]%
\\
\>[6]{}\Rightarrow \Conid{Proxy}\;\Varid{s}\to \Varid{x}\to \Conid{Edis}\;\Varid{xs}\;(\Conid{Set}\;\Varid{xs}\;\Varid{s}\;(\Conid{StringOf}\;\Varid{x}))\;(\Conid{Either}\;\Conid{Reply}\;\Conid{Status}){}\<[E]%
\\
\>[B]{}\Varid{set}\;\Varid{key}\;\Varid{val}\mathrel{=}\Conid{Edis}\mathbin{\$}\Varid{\Conid{Hedis}.set}\;(\Varid{encodeKey}\;\Varid{key})\;(\Varid{encode}\;\Varid{val})~~,{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
For example, executing \ensuremath{\Varid{set}\;(\Conid{Proxy}\mathbin{::}\Conid{Proxy}\;\text{\tt \char34 A\char34})\;\Conid{True}} updates the dictionary
with an entry \ensuremath{\mbox{\textquotesingle}(\text{\tt \char34 A\char34},\Conid{StringOf}\;\Conid{Bool})}. If \ensuremath{\text{\tt \char34 A\char34}} is not in the dictionary,
this entry is added; otherwise the old type of \ensuremath{\text{\tt \char34 A\char34}} is updated to
\ensuremath{\Conid{StringOf}\;\Conid{Bool}}.

\Redis{} command \texttt{INCR} reads the string associated with the given key,
parse it as an integer, and increments it, before storing it back. The command
\texttt{INCRBYFLOAT} increments the floating number, associated to the given
key. They can be
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{14}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{incr}{}\<[7]%
\>[7]{}\mathbin{::}(\Conid{KnownSymbol}\;\Varid{s},\Conid{Get}\;\Varid{xs}\;\Varid{s}\mathord{\sim}\Conid{Just}\;(\Conid{StringOf}\;\Conid{Integer})){}\<[E]%
\\
\>[7]{}\Rightarrow \Conid{Proxy}\;\Varid{s}\to \Conid{Edis}\;\Varid{xs}\;\Varid{xs}\;(\Conid{Either}\;\Conid{Reply}\;\Conid{Integer}){}\<[E]%
\\
\>[B]{}\Varid{incr}\;\Varid{key}\mathrel{=}\Conid{Edis}\mathbin{\$}\Varid{\Conid{Hedis}.incr}\;(\Varid{encodeKey}\;\Varid{key})~~,{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{incrbyfloat}{}\<[14]%
\>[14]{}\mathbin{::}(\Conid{KnownSymbol}\;\Varid{s},\Conid{Get}\;\Varid{xs}\;\Varid{s}\mathord{\sim}\Conid{Just}\;(\Conid{StringOf}\;\Conid{Double})){}\<[E]%
\\
\>[14]{}\Rightarrow \Conid{Proxy}\;\Varid{s}\to \Conid{Double}\to \Conid{Edis}\;\Varid{xs}\;\Varid{xs}\;(\Conid{Either}\;\Conid{Reply}\;\Conid{Double}){}\<[E]%
\\
\>[B]{}\Varid{incrbyfloat}\;\Varid{key}\;\Varid{eps}\mathrel{=}\Conid{Edis}\mathbin{\$}\Varid{\Conid{Hedis}.incrbyfloat}\;(\Varid{encodeKey}\;\Varid{key})\;\Varid{eps}~~.{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Notice the use of (\ensuremath{\mathord{\sim}}), \emph{equality constraints}~\cite{typeeq}, to enforce
that the intended type of value associated with key \ensuremath{\Varid{s}} must respectively be
\ensuremath{\Conid{Integer}} and \ensuremath{\Conid{Double}}. The function \ensuremath{\Varid{incr}} is allowed to be called only
in a context where the type checker is able to reduce \ensuremath{\Conid{Get}\;\Varid{xs}\;\Varid{s}} to
\ensuremath{\Conid{Just}\;(\Conid{StringOf}\;\Conid{Integer})}. Similarly with \ensuremath{\Varid{incrbyfloat}}.

\todo{Some more interesting functions that uses IF and FromJust, etc.
What about \ensuremath{\Varid{lset}}?}

\subsection{Constraint Disjunctions}

Recall, from Section \ref{sec:introduction}, that commands \texttt{LPUSH key
val} and \texttt{LLEN key} returns normally either when \ensuremath{\Varid{key}} does not present
in the data store, or when \ensuremath{\Varid{key}} presents and is associated to a list.
What we wish to have in their constraint is thus a predicate equivalent to \ensuremath{\Conid{Get}\;\Varid{xs}\;\Varid{s}\doubleequals\Conid{Just}\;(\Conid{ListOf}\;\Varid{x})\mathrel{\vee}\neg \;(\Conid{Member}\;\Varid{xs}\;\Varid{s})}.

To impose a conjunctive constraint \ensuremath{\Conid{P}\mathrel{\wedge}\Conid{Q}}, one may simply put them both in the
type: \ensuremath{(\Conid{P},\Conid{Q})\Rightarrow \mathbin{...}}. Expressing disjunctive constraints is only slightly
harder, thanks to our type-level functions. Various operators for type-level
boolean and equality are defined in \text{Data.Type.Bool} and
\text{Data.Type.Equality}, like how we defined \ensuremath{\Conid{Or}} in Section
\ref{sec:type-fun}. We may thus write the predicate as:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Conid{Get}\;\Varid{xs}\;\Varid{s}\doubleequals\Conid{Just}\;(\Conid{ListOf}\;\Varid{x})\mathbin{`\Conid{Or}`}\Conid{Not}\;(\Conid{Member}\;\Varid{xs}\;\Varid{s})~~.{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
To avoid referring to \ensuremath{\Varid{x}}, which might not exist, we define an auxiliary predicate \ensuremath{\Conid{IsList}\mathbin{::}\Conid{Maybe}\mathbin{*}\to \Conid{Bool}}:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{23}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{type}\;\Varid{family}\;\Conid{IsList}\;(\Varid{x}\mathbin{::}\mathbin{*})\mathbin{::}\Conid{Bool}\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Conid{IsList}\;(\Conid{ListOf}\;\Varid{n})\mathrel{=}\mbox{\textquotesingle}\Conid{True}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Conid{IsList}\;\Varid{x}{}\<[23]%
\>[23]{}\mathrel{=}\mbox{\textquotesingle}\Conid{False}~~.{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
As many other list-related commands also have this ``List or nothing'' semantics, we give the type constraint a name:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Conid{ListOrNX}\;\Varid{xs}\;\Varid{s}\mathrel{=}(\Conid{IsList}\;(\Conid{Get}\;\Varid{xs}\;\Varid{s})\mathrel{\vee}\Conid{Not}\;(\Conid{Member}\;\Varid{xs}\;\Varid{s}))\mathord{\sim}\Conid{True}~~.{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\noindent The complete implementation of \text{LLEN} with
\ensuremath{\Conid{ListOrNX}} is therefore:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{lpush}\mathbin{::}(\Conid{KnownSymbol}\;\Varid{s},\Conid{Serialize}\;\Varid{x},\Conid{ListOrNX}\;\Varid{xs}\;\Varid{s}){}\<[E]%
\\
\>[B]{}\hsindent{7}{}\<[7]%
\>[7]{}\Rightarrow \Conid{Proxy}\;\Varid{s}\to \Varid{x}\to \Conid{Edis}\;\Varid{xs}\;(\Conid{Set}\;\Varid{xs}\;\Varid{s}\;(\Conid{ListOf}\;\Varid{x}))\;(\Conid{Either}\;\Conid{Reply}\;\Conid{Integer}){}\<[E]%
\\
\>[B]{}\Varid{lpush}\;\Varid{key}\;\Varid{val}\mathrel{=}\Conid{Edis}\mathbin{\$}\Varid{\Conid{Redis}.lpush}\;(\Varid{encodeKey}\;\Varid{key})\;[\mskip1.5mu \Varid{encode}\;\Varid{val}\mskip1.5mu]~~,{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{llen}{}\<[7]%
\>[7]{}\mathbin{::}(\Conid{KnownSymbol}\;\Varid{s},\Conid{ListOrNX}\;\Varid{xs}\;\Varid{s}){}\<[E]%
\\
\>[7]{}\Rightarrow \Conid{Proxy}\;\Varid{s}\to \Conid{Edis}\;\Varid{xs}\;\Varid{xs}\;(\Conid{Either}\;\Conid{Reply}\;\Conid{Integer}){}\<[E]%
\\
\>[B]{}\Varid{llen}\;\Varid{key}\mathrel{=}\Conid{Edis}\mathbin{\$}\Varid{\Conid{Hedis}.llen}\;(\Varid{encodeKey}\;\Varid{key})~~.{}\<[E]%
\ColumnHook
\end{hscode}\resethooks



\todo{why cite \cite{singletons} here?}

% The type expression above has kind |Bool|, we could make it
%  a type constraint by asserting equality.
%
% With \emph{constraint kind}, a recent addition to GHC, type constraints now has
%  its own kind: |Constraint|. That means type constraints
%  are not restricted to the left side of a |=>| anymore,
%  they could appear in anywhere that accepts something of kind
%  |Constraint|, and any type that has kind
%  |Constraint| can also be used as a type constraint.
%  \footnote{See \url{https://downloads.haskell.org/~ghc/7.4.1/docs/html/users_guide/constraint-kind.html}.}

\subsection{Assertions}
\label{sec:assertions}

Finally, the creation/update behavior of \Redis{} functions is, in our opinion,
very error-prone. It might be preferable if we can explicit declare some new
keys, after ensure that they do not already exist (in our types), and renounce
them and forbid further access when we are sure that they shall not be referred
to anymore. This can be done below:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{declare}\mathbin{::}(\Conid{KnownSymbol}\;\Varid{s},\Conid{Member}\;\Varid{xs}\;\Varid{s}\mathord{\sim}\Conid{False}){}\<[E]%
\\
\>[B]{}\hsindent{9}{}\<[9]%
\>[9]{}\Rightarrow \Conid{Proxy}\;\Varid{s}\to \Conid{Proxy}\;\Varid{x}\to \Conid{Edis}\;\Varid{xs}\;(\Conid{Set}\;\Varid{xs}\;\Varid{s}\;\Varid{x})\;(){}\<[E]%
\\
\>[B]{}\Varid{declare}\;\Varid{s}\;\Varid{x}\mathrel{=}\Conid{Edis}\mathbin{\$}\Varid{return}\;()~~,{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{renounce}\mathbin{::}(\Conid{KnownSymbol}\;\Varid{s},\Conid{Member}\;\Varid{xs}\;\Varid{s}\mathord{\sim}\Conid{True}){}\<[E]%
\\
\>[B]{}\hsindent{9}{}\<[9]%
\>[9]{}\Rightarrow \Conid{Proxy}\;\Varid{s}\to \Conid{Edis}\;\Varid{xs}\;(\Conid{Del}\;\Varid{xs}\;\Varid{s})\;(){}\<[E]%
\\
\>[B]{}\Varid{renounce}\;\Varid{s}\mathrel{=}\Conid{Edis}\mathbin{\$}\Varid{return}\;()~~.{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
The command \ensuremath{\Varid{declare}\;\Varid{s}\;\Varid{x}} adds a new key \ensuremath{\Varid{s}} with type \ensuremath{\Varid{x}} to the dictionary,
if it does not already exist. Dually, \ensuremath{\Varid{renounce}} removes a key from the
dictionary. Even though it may still exist in the data store, it is not allowed
to be referred to. The command \ensuremath{\Varid{start}} initializes the dictionary to \ensuremath{\mbox{\textquotesingle}[~]}:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{start}\mathbin{::}\Conid{Edis}\;\mbox{\textquotesingle}[~]\;\mbox{\textquotesingle}[~]\;(){}\<[E]%
\\
\>[B]{}\Varid{start}\mathrel{=}\Conid{Edis}\mathbin{\$}\Varid{return}\;()~~.{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\subsection{A Larger Example}

The following program increases the value of \ensuremath{\text{\tt \char34 A\char34}} as an integer, push the result of the increment to list \ensuremath{\text{\tt \char34 L\char34}}, and then pops it out:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{13}{@{}>{\hspre}l<{\hspost}@{}}%
\column{19}{@{}>{\hspre}l<{\hspost}@{}}%
\column{23}{@{}>{\hspre}l<{\hspost}@{}}%
\column{24}{@{}>{\hspre}l<{\hspost}@{}}%
\column{33}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{main}\mathbin{::}\Conid{IO}\;(){}\<[E]%
\\
\>[B]{}\Varid{main}\mathrel{=}\mathbf{do}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Varid{conn}{}\<[13]%
\>[13]{}\leftarrow \Varid{connect}\;\Varid{defaultConnectInfo}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Varid{result}{}\<[13]%
\>[13]{}\leftarrow \Varid{runRedis}\;\Varid{conn}\mathbin{\$}\Varid{unEdis}\mathbin{\$}\Varid{start}{}\<[E]%
\\
\>[5]{}\hsindent{4}{}\<[9]%
\>[9]{}\mathbin{`\Varid{bind}`}\lambda \anonymous \to {}\<[24]%
\>[24]{}\Varid{declare}\;(\Conid{Proxy}\mathbin{::}\Conid{Proxy}\;\text{\tt \char34 A\char34})\;(\Conid{Proxy}\mathbin{::}\Conid{Proxy}\;\Conid{Integer}){}\<[E]%
\\
\>[5]{}\hsindent{4}{}\<[9]%
\>[9]{}\mathbin{`\Varid{bind}`}\lambda \anonymous \to {}\<[24]%
\>[24]{}\Varid{incr}\;(\Conid{Proxy}\mathbin{::}\Conid{Proxy}\;\text{\tt \char34 A\char34}){}\<[E]%
\\
\>[5]{}\hsindent{4}{}\<[9]%
\>[9]{}\mathbin{`\Varid{bind}`}\lambda \Varid{n}\to {}\<[23]%
\>[23]{}\mathbf{case}\;\Varid{n}\;\mathbf{of}{}\<[E]%
\\
\>[9]{}\hsindent{4}{}\<[13]%
\>[13]{}\Conid{Left}\;{}\<[19]%
\>[19]{}\Varid{err}{}\<[24]%
\>[24]{}\to \Varid{lpush}\;(\Conid{Proxy}\mathbin{::}\Conid{Proxy}\;\text{\tt \char34 L\char34})\;\mathrm{0}{}\<[E]%
\\
\>[9]{}\hsindent{4}{}\<[13]%
\>[13]{}\Conid{Right}\;\Varid{n}{}\<[24]%
\>[24]{}\to \Varid{lpush}\;(\Conid{Proxy}\mathbin{::}\Conid{Proxy}\;\text{\tt \char34 L\char34})\;\Varid{n}{}\<[E]%
\\
\>[5]{}\hsindent{4}{}\<[9]%
\>[9]{}\mathbin{`\Varid{bind}`}\lambda \anonymous \to {}\<[24]%
\>[24]{}\Varid{lpop}\;{}\<[33]%
\>[33]{}(\Conid{Proxy}\mathbin{::}\Conid{Proxy}\;\text{\tt \char34 L\char34}){}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Varid{print}\;\Varid{result}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The syntax is pretty heavy, like the old days when there's no
 \emph{do-notation}\cite{history}. But if we don't need any variable bindings
 between operations, we could compose these commands with a sequencing operator
 \ensuremath{(\mathbin{>>>})}.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}(\mathbin{>>>})\mathbin{::}\Conid{IMonad}\;\Varid{m}\Rightarrow \Varid{m}\;\Varid{p}\;\Varid{q}\;\Varid{a}\to \Varid{m}\;\Varid{q}\;\Varid{r}\;\Varid{b}\to \Varid{m}\;\Varid{p}\;\Varid{r}\;\Varid{b}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{17}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{program}\mathrel{=}\Varid{start}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\mathbin{>>>}\Varid{declare}\;(\Conid{Proxy}\mathbin{::}\Conid{Proxy}\;\text{\tt \char34 A\char34})\;(\Conid{Proxy}\mathbin{::}\Conid{Proxy}\;\Conid{Integer}){}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\mathbin{>>>}\Varid{incr}\;{}\<[17]%
\>[17]{}(\Conid{Proxy}\mathbin{::}\Conid{Proxy}\;\text{\tt \char34 A\char34}){}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\mathbin{>>>}\Varid{lpush}\;{}\<[17]%
\>[17]{}(\Conid{Proxy}\mathbin{::}\Conid{Proxy}\;\text{\tt \char34 L\char34})\;\mathrm{0}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\mathbin{>>>}\Varid{lpop}\;{}\<[17]%
\>[17]{}(\Conid{Proxy}\mathbin{::}\Conid{Proxy}\;\text{\tt \char34 L\char34}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
