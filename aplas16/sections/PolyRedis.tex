%% ODER: format ==         = "\mathrel{==}"
%% ODER: format /=         = "\neq "
%
%
\makeatletter
\@ifundefined{lhs2tex.lhs2tex.sty.read}%
  {\@namedef{lhs2tex.lhs2tex.sty.read}{}%
   \newcommand\SkipToFmtEnd{}%
   \newcommand\EndFmtInput{}%
   \long\def\SkipToFmtEnd#1\EndFmtInput{}%
  }\SkipToFmtEnd

\newcommand\ReadOnlyOnce[1]{\@ifundefined{#1}{\@namedef{#1}{}}\SkipToFmtEnd}
\usepackage{amstext}
\usepackage{amssymb}
\usepackage{stmaryrd}
\DeclareFontFamily{OT1}{cmtex}{}
\DeclareFontShape{OT1}{cmtex}{m}{n}
  {<5><6><7><8>cmtex8
   <9>cmtex9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmtex10}{}
\DeclareFontShape{OT1}{cmtex}{m}{it}
  {<-> ssub * cmtt/m/it}{}
\newcommand{\texfamily}{\fontfamily{cmtex}\selectfont}
\DeclareFontShape{OT1}{cmtt}{bx}{n}
  {<5><6><7><8>cmtt8
   <9>cmbtt9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmbtt10}{}
\DeclareFontShape{OT1}{cmtex}{bx}{n}
  {<-> ssub * cmtt/bx/n}{}
\newcommand{\tex}[1]{\text{\texfamily#1}}	% NEU

\newcommand{\Sp}{\hskip.33334em\relax}


\newcommand{\Conid}[1]{\mathit{#1}}
\newcommand{\Varid}[1]{\mathit{#1}}
\newcommand{\anonymous}{\kern0.06em \vbox{\hrule\@width.5em}}
\newcommand{\plus}{\mathbin{+\!\!\!+}}
\newcommand{\bind}{\mathbin{>\!\!\!>\mkern-6.7mu=}}
\newcommand{\rbind}{\mathbin{=\mkern-6.7mu<\!\!\!<}}% suggested by Neil Mitchell
\newcommand{\sequ}{\mathbin{>\!\!\!>}}
\renewcommand{\leq}{\leqslant}
\renewcommand{\geq}{\geqslant}
\usepackage{polytable}

%mathindent has to be defined
\@ifundefined{mathindent}%
  {\newdimen\mathindent\mathindent\leftmargini}%
  {}%

\def\resethooks{%
  \global\let\SaveRestoreHook\empty
  \global\let\ColumnHook\empty}
\newcommand*{\savecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\savecolumns[#1]}}
\newcommand*{\restorecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\restorecolumns[#1]}}
\newcommand*{\aligncolumn}[2]%
  {\g@addto@macro\ColumnHook{\column{#1}{#2}}}

\resethooks

\newcommand{\onelinecommentchars}{\quad-{}- }
\newcommand{\commentbeginchars}{\enskip\{-}
\newcommand{\commentendchars}{-\}\enskip}

\newcommand{\visiblecomments}{%
  \let\onelinecomment=\onelinecommentchars
  \let\commentbegin=\commentbeginchars
  \let\commentend=\commentendchars}

\newcommand{\invisiblecomments}{%
  \let\onelinecomment=\empty
  \let\commentbegin=\empty
  \let\commentend=\empty}

\visiblecomments

\newlength{\blanklineskip}
\setlength{\blanklineskip}{0.66084ex}

\newcommand{\hsindent}[1]{\quad}% default is fixed indentation
\let\hspre\empty
\let\hspost\empty
\newcommand{\NB}{\textbf{NB}}
\newcommand{\Todo}[1]{$\langle$\textbf{To do:}~#1$\rangle$}

\EndFmtInput
\makeatother
%
%
%
%
%
%
% This package provides two environments suitable to take the place
% of hscode, called "plainhscode" and "arrayhscode". 
%
% The plain environment surrounds each code block by vertical space,
% and it uses \abovedisplayskip and \belowdisplayskip to get spacing
% similar to formulas. Note that if these dimensions are changed,
% the spacing around displayed math formulas changes as well.
% All code is indented using \leftskip.
%
% Changed 19.08.2004 to reflect changes in colorcode. Should work with
% CodeGroup.sty.
%
\ReadOnlyOnce{polycode.fmt}%
\makeatletter

\newcommand{\hsnewpar}[1]%
  {{\parskip=0pt\parindent=0pt\par\vskip #1\noindent}}

% can be used, for instance, to redefine the code size, by setting the
% command to \small or something alike
\newcommand{\hscodestyle}{}

% The command \sethscode can be used to switch the code formatting
% behaviour by mapping the hscode environment in the subst directive
% to a new LaTeX environment.

\newcommand{\sethscode}[1]%
  {\expandafter\let\expandafter\hscode\csname #1\endcsname
   \expandafter\let\expandafter\endhscode\csname end#1\endcsname}

% "compatibility" mode restores the non-polycode.fmt layout.

\newenvironment{compathscode}%
  {\par\noindent
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \let\hspre\(\let\hspost\)%
   \pboxed}%
  {\endpboxed\)%
   \par\noindent
   \ignorespacesafterend}

\newcommand{\compaths}{\sethscode{compathscode}}

% "plain" mode is the proposed default.
% It should now work with \centering.
% This required some changes. The old version
% is still available for reference as oldplainhscode.

\newenvironment{plainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\hspre\(\let\hspost\)%
   \pboxed}%
  {\endpboxed%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newenvironment{oldplainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

% Here, we make plainhscode the default environment.

\newcommand{\plainhs}{\sethscode{plainhscode}}
\newcommand{\oldplainhs}{\sethscode{oldplainhscode}}
\plainhs

% The arrayhscode is like plain, but makes use of polytable's
% parray environment which disallows page breaks in code blocks.

\newenvironment{arrayhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\parray}%
  {\endparray\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newcommand{\arrayhs}{\sethscode{arrayhscode}}

% The mathhscode environment also makes use of polytable's parray 
% environment. It is supposed to be used only inside math mode 
% (I used it to typeset the type rules in my thesis).

\newenvironment{mathhscode}%
  {\parray}{\endparray}

\newcommand{\mathhs}{\sethscode{mathhscode}}

% texths is similar to mathhs, but works in text mode.

\newenvironment{texthscode}%
  {\(\parray}{\endparray\)}

\newcommand{\texths}{\sethscode{texthscode}}

% The framed environment places code in a framed box.

\def\codeframewidth{\arrayrulewidth}
\RequirePackage{calc}

\newenvironment{framedhscode}%
  {\parskip=\abovedisplayskip\par\noindent
   \hscodestyle
   \arrayrulewidth=\codeframewidth
   \tabular{@{}|p{\linewidth-2\arraycolsep-2\arrayrulewidth-2pt}|@{}}%
   \hline\framedhslinecorrect\\{-1.5ex}%
   \let\endoflinesave=\\
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \framedhslinecorrect\endoflinesave{.5ex}\hline
   \endtabular
   \parskip=\belowdisplayskip\par\noindent
   \ignorespacesafterend}

\newcommand{\framedhslinecorrect}[2]%
  {#1[#2]}

\newcommand{\framedhs}{\sethscode{framedhscode}}

% The inlinehscode environment is an experimental environment
% that can be used to typeset displayed code inline.

\newenvironment{inlinehscode}%
  {\(\def\column##1##2{}%
   \let\>\undefined\let\<\undefined\let\\\undefined
   \newcommand\>[1][]{}\newcommand\<[1][]{}\newcommand\\[1][]{}%
   \def\fromto##1##2##3{##3}%
   \def\nextline{}}{\) }%

\newcommand{\inlinehs}{\sethscode{inlinehscode}}

% The joincode environment is a separate environment that
% can be used to surround and thereby connect multiple code
% blocks.

\newenvironment{joincode}%
  {\let\orighscode=\hscode
   \let\origendhscode=\endhscode
   \def\endhscode{\def\hscode{\endgroup\def\@currenvir{hscode}\\}\begingroup}
   %\let\SaveRestoreHook=\empty
   %\let\ColumnHook=\empty
   %\let\resethooks=\empty
   \orighscode\def\hscode{\endgroup\def\@currenvir{hscode}}}%
  {\origendhscode
   \global\let\hscode=\orighscode
   \global\let\endhscode=\origendhscode}%

\makeatother
\EndFmtInput
%

\ReadOnlyOnce{Formatting.fmt}%
\makeatletter

\let\Varid\mathit
\let\Conid\mathsf

\def\commentbegin{\quad\{\ }
\def\commentend{\}}

\newcommand{\ty}[1]{\Conid{#1}}
\newcommand{\con}[1]{\Conid{#1}}
\newcommand{\id}[1]{\Varid{#1}}
\newcommand{\cl}[1]{\Varid{#1}}
\newcommand{\opsym}[1]{\mathrel{#1}}

\newcommand\Keyword[1]{\textbf{\textsf{#1}}}
\newcommand\Hide{\mathbin{\downarrow}}
\newcommand\Reveal{\mathbin{\uparrow}}


%% Paper-specific keywords


\makeatother
\EndFmtInput

\section{Making Redis Polymorphic}
\label{sec:polymorphic-redis}

Redis supports many different datatypes, these datatypes as can be viewed as
 \emph{containers} of strings. For example, lists (of strings),
 sets (of strings), and strings themselves.

\subsection{Denoting Containers}
Most Redis commands only work with a certain type of these containers. To
 annotate what container a key is associated with, we introduce these types for
 the universe of containers.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{data}\;\Conid{Strings}{}\<[E]%
\\
\>[B]{}\mathbf{data}\;\Conid{Lists}{}\<[E]%
\\
\>[B]{}\mathbf{data}\;\Conid{Sets}{}\<[E]%
\\
\>[B]{}\mathbin{...}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\text{SET} stores a string, regardless the datatype the key was
 associated with. Now we could implement \text{SET} like this:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{25}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{set}\mathbin{::}\Conid{KnownSymbol}\;\Varid{s}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Rightarrow \Conid{Proxy}\;\Varid{s}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\to \Conid{ByteString}{}\<[25]%
\>[25]{}\mbox{\onelinecomment  data to store}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\to \Conid{Edis}\;\Varid{xs}\;(\Conid{Set}\;\Varid{xs}\;\Varid{s}\;\Conid{Strings})\;(\Conid{Either}\;\Conid{Reply}\;\Conid{Status}){}\<[E]%
\\
\>[B]{}\Varid{set}\;\Varid{key}\;\Varid{val}\mathrel{=}\Conid{Edis}\mathbin{\$}\Varid{\Conid{Hedis}.set}\;(\Varid{encodeKey}\;\Varid{key})\;\Varid{val}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

After \text{SET}, the key will be associated with
 \ensuremath{\Conid{Strings}} in the dictionary, indicating that it's a string.

\subsection{Automatic Data Serialization}

But in the real world, raw binary strings are hardly useful, people would
 usually serialize their data into strings before storing them, and deserialize
 them back when in need.

Instead of letting users writing these boilerplates, we can do these
 serializations/deserializations for them. With the help from
 \text{cereal}, a binary serialization library.
 \text{cereal} comes with these two functions:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{8}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{encode}\mathbin{::}\Conid{Serialize}\;\Varid{a}{}\<[E]%
\\
\>[B]{}\hsindent{8}{}\<[8]%
\>[8]{}\Rightarrow \Varid{a}\to \Conid{ByteString}\;\Conid{Source}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{decode}\mathbin{::}\Conid{Serialize}\;\Varid{a}{}\<[E]%
\\
\>[B]{}\hsindent{8}{}\<[8]%
\>[8]{}\Rightarrow \Conid{ByteString}\to \Conid{Either}\;\Conid{String}\;\Varid{a}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Which would do all the works for us, as long as the datatype it's handling is
 an instance of class \ensuremath{\Conid{Serialize}}.\footnotemark

\footnotetext{The methods of \ensuremath{\Conid{Serialize}} will have default
 generic implementations for all datatypes with some language extensions
 enabled, no sweat!}

\subsection{Extending container types}
We rename container types and extend it with an extra type argument,
 to indicate what kind of encoded value it's holding.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{data}\;\Conid{StringOf}\;\Varid{x}{}\<[E]%
\\
\>[B]{}\mathbf{data}\;\Conid{ListOf}\;\Varid{x}{}\<[E]%
\\
\>[B]{}\mathbf{data}\;\Conid{SetOf}\;\Varid{x}{}\<[E]%
\\
\>[B]{}\mathbin{...}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\ensuremath{\Varid{set}} reimplemented with extended container types:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{16}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{set}\mathbin{::}(\Conid{KnownSymbol}\;\Varid{s},\Conid{Serialize}\;\Varid{x}){}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Rightarrow \Conid{Proxy}\;\Varid{s}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\to \Varid{x}{}\<[16]%
\>[16]{}\mbox{\onelinecomment  can be anything, as long as it's serializable}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\to \Conid{Edis}\;\Varid{xs}\;(\Conid{Set}\;\Varid{xs}\;\Varid{s}\;(\Conid{StringOf}\;\Varid{x}))\;(\Conid{Either}\;\Conid{Reply}\;\Conid{Status}){}\<[E]%
\\
\>[B]{}\Varid{set}\;\Varid{key}\;\Varid{val}\mathrel{=}\Conid{Edis}\mathbin{\$}\Varid{\Conid{Hedis}.set}\;(\Varid{encodeKey}\;\Varid{key})\;(\Varid{encode}\;\Varid{val}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

For example, if we execute \ensuremath{\Varid{set}\;(\Conid{Proxy}\mathbin{::}\Conid{Proxy}\;\text{\tt \char34 A\char34})\;\Conid{True}},
 a new entry \text{'}\ensuremath{(\text{\tt \char34 A\char34},\Conid{StringOf}\;\Conid{Bool})} will
 be inserted to the dictionary.

\subsection{Handling \text{INCR}}

Commands such as \text{INCR} and \text{INCRBYFLOAT}, are
 not only container-specific, they also have some requirements on what types of
 value they could operate with.

We could handle this by mapping Redis's strings of integers and floats to
 Haskell's \text{Integer} and \text{Double}.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{6}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{incr}\mathbin{::}(\Conid{KnownSymbol}\;\Varid{s}{}\<[E]%
\\
\>[B]{}\hsindent{7}{}\<[7]%
\>[7]{},\Conid{Get}\;\Varid{xs}\;\Varid{s}\mathord{\sim}\Conid{Just}\;(\Conid{StringOf}\;\Conid{Integer})){}\<[E]%
\\
\>[B]{}\hsindent{6}{}\<[6]%
\>[6]{}\Rightarrow \Conid{Proxy}\;\Varid{s}{}\<[E]%
\\
\>[B]{}\hsindent{6}{}\<[6]%
\>[6]{}\to \Conid{Edis}\;\Varid{xs}\;\Varid{xs}\;(\Conid{Either}\;\Conid{Reply}\;\Conid{Integer}){}\<[E]%
\\
\>[B]{}\Varid{incr}\;\Varid{key}\mathrel{=}\Conid{Edis}\mathbin{\$}\Varid{\Conid{Hedis}.incr}\;(\Varid{encodeKey}\;\Varid{key}){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{incrbyfloat}\mathbin{::}(\Conid{KnownSymbol}\;\Varid{s}{}\<[E]%
\\
\>[B]{}\hsindent{6}{}\<[6]%
\>[6]{},\Conid{Get}\;\Varid{xs}\;\Varid{s}\mathord{\sim}\Conid{Just}\;(\Conid{StringOf}\;\Conid{Double})){}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Rightarrow \Conid{Proxy}\;\Varid{s}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\to \Conid{Double}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\to \Conid{Edis}\;\Varid{xs}\;\Varid{xs}\;(\Conid{Either}\;\Conid{Reply}\;\Conid{Double}){}\<[E]%
\\
\>[B]{}\Varid{incrbyfloat}\;\Varid{key}\;\Varid{n}\mathrel{=}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Conid{Edis}\mathbin{\$}\Varid{\Conid{Hedis}.incrbyfloat}\;(\Varid{encodeKey}\;\Varid{key})\;\Varid{n}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
